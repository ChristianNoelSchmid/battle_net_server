use std::sync::Arc;

use axum::{
    extract::{State, FromRef},
    response::IntoResponse,
    Json, routing::{put, post}, Router
};

use tower_cookies::{Cookies, Cookie};

use serde::{Deserialize, Serialize};

use crate::services::auth_service::{AuthService, error::AuthServiceError};

///
/// Payload for creating a Church User
/// 
#[derive(Debug, Deserialize, Serialize)]
pub struct CreateUserPayload {
    pub email: String,
    pub pwd: String,
    pub card_idx: i64
}

///
/// Payload for the login route
/// Client sent email and password
///
#[derive(Debug, Deserialize, Serialize)]
pub struct LoginPayload {
    pub email: Option<String>,
    pub pwd: Option<String>,
    pub access_token: Option<String>,
}

#[derive(Clone, FromRef)]
struct AuthRoutesState {
    auth_service: Arc<dyn AuthService>,
}

///
/// Payload for the authorization route
/// Contains access token generated by this server previously
///
#[derive(Debug, Deserialize, Serialize)]
pub struct AuthPayload {
    pub access_token: String,
}

pub fn routes(auth_service: Arc<dyn AuthService>) -> Router {
    Router::new()
        // Routes
        .route("/refresh", put(refresh))
        .route("/login", post(login))
        // State
        .with_state(AuthRoutesState { auth_service })
}



///
/// Generates new access token and refresh token, using the login information
///
async fn login(
    State(auth_service): State<Arc<dyn AuthService>>,
    cookies: Cookies,
    Json(model): Json<LoginPayload>,
) -> impl IntoResponse {
    let res = if let Some(email) = model.email {
        auth_service.try_accept_creds(email, model.pwd.unwrap()).await
    } else {
        let access_token = model.access_token.unwrap();
        auth_service.try_accept_access_token(&access_token).await
    };
    
    res.and_then(|tokens| {
        cookies.add(create_cookie(tokens.refresh_token));
        Ok(Json(tokens.access_token))
    })
}

///
/// Attempts to refresh a session with a cookie refresh token,
/// creating a new access and refresh token from the given one
///
async fn refresh(
    State(auth_service): State<Arc<dyn AuthService>>,
    cookies: Cookies,
) -> impl IntoResponse {
    return match cookies.get("refresh-token") {
        Some(refr_token) => {
            let refr_token = refr_token.value().to_string();
            let tokens = auth_service.try_accept_refresh(refr_token.clone()).await?;
            cookies.add(create_cookie(tokens.refresh_token));

            Ok(Json(tokens.access_token))
        }
        None => Err(AuthServiceError::CookieNotFound),
    };
}

fn create_cookie(refr_token: String) -> Cookie<'static> {
    // Create the refresh token cookie
    let mut cookie = Cookie::new("refresh-token", refr_token);
    cookie.set_http_only(true);
    cookie
}